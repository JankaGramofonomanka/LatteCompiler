# LatteCompiler

This is a compiler of the Latte programming language, whose description can be 
found here: https://www.mimuw.edu.pl/~ben/Zajecia/Mrj2020/Latte/
(in Polish)

## Usage

- To build the project, use the Makefile, ie. run
  ```
  make
  ```

- To verify semantic correctness of a program, run
  ```
  ./latc [FILE.lat]
  ```
  where `FILE.lat` is the file with code you want to verify.
  If the code is correct, the output will be
  ```
  OK
  ```
  If the code is incorrect, the output will be
  ```
  ERROR
  [MSG]
  ```
  where `MSG` is a message specifying what is incorrect about the code.



- You can compile your code to llvm by running
  ```
  ./latc_llvm [FILE].lat
  ```
  where `FILE.lat` is the file with code you want to compile.
  the llvm code will be outputed to a file `FILE.ll` and then linked with 
  `./lib/runtime.ll`. The linked bytecode will be outputed to `FILE.bc`

  You can then run the program using `lli`:
  ```
  lli [FILE].bc
  ```

## Libraries
In this project I use the following non-standard libraries:
- singletons
  
  https://hackage.haskell.org/package/singletons

- dependent-map
  
  https://hackage.haskell.org/package/dependent-map

- some
  
  https://hackage.haskell.org/package/some

## Language Extensions

The following language extensions are implemented:
- arrays and for loops
- structs
- objects
- virtual methods

## Design decisions

- Syntax / Semanics

  - `null` and `self` are keywords, and cannot be used as identifiers, 
    no mater the context.

  - A non-void function must have a return statement as the last statement 
    in all its reachable branches that do not have a successor.

    A reachable branch is a branch that is not discarded after evaluating 
    constant expressions, that is expressions that do not contain variables and 
    function calls.

    In particular `4 + 23` is a constant expression, but in `int x = 4;x + 3;`,
    `x + 3` is not a constant expression.

    If a constant expression is a condition in an if statement, it will be 
    evaluated and an appropriate branch of the statement will be selected to be put in place of the entire if statement.

    Similarly, if a constant expression is a condition in a while loop, 
    the body of the loop will be discarded if it evaluates to `false`, 
    or if it evaluates to `true`, the loop will be replaced with a `forever` loop,
    which is a special construct that exists only in the abstract 
    representation of the code, not in the Latte syntax. In such case the code 
    after the loop will be discarded.

    In particular, the following code is incorrect:
    ```
    int f() {}

      while (true) {
        # no return statement here
      }

      # this gets ignored
      return 5;
    }
    ```
    However this is correct:
    ```
    int f() {

      if (true) {
        return 5;

      } else {
        # no return statement here
        # this gets ignored
      }
    }
    ```
  - When defining a class that inherits from another class, 
    the definition of the parent class must be above the child class. 
    This is to avoid searchong for circular inheritance 
    (ie. A inherits from B, B inherits from A).

    In particular this code is correct:
    ```
    class A {}
    class B extends A {}
    ```

    while this is not:
    ```
    class A extends B {}
    class B {}
    ```

## Project directory structure:

A file in parenthesis means that it will exist after the project is built.

```
./
|
|- bin
|  | # contains executables called by `latc` and `latc_llvm`
|  |
|  |- (latc_exe)
|  |- (latc_llvm_exe)
|
|- lib
|  |- runtime.ll
|
|- src
|  |- frontend
|  |  |- Main.hs
|  |  |  # compiles to bin/latc_exe - the executable called by ./latc
|  |
|  |- llvm
|  |  |- Main.hs
|  |  |  # compiles to bin/latc_llvm_exe - the executable called by ./latc_llvm
|  |
|  |- src
|  |  |- FromBNFC
|  |  |  |  # contains files generated by BNFC
|  |  |  |
|  |  |  |- AbsLatte.hs
|  |  |  |- ErrM.hs
|  |  |  |- LexLatte.hs
|  |  |  |- ParLatte.hs
|  |  |  |- PrintLatte.hs
|  |  |
|  |  |- LLVM
|  |  |  | # contains code pertaining to llvm code and its generation from 
|  |  |  | # abstract dependent syntax (src/src/Syntax/SyntaxDep.hs)
|  |  |  |
|  |  |  |- Cleanup.hs
|  |  |  |- Convert.hs
|  |  |  |- LLVM.hs
|  |  |  |- LLVMGetters.hs
|  |  |  |- Print.hs
|  |  |  |- State.hs
|  |  |  |- StateUtils.hs
|  |  |  |- TypeConversion.hs
|  |  |
|  |  |- Optimization
|  |  |  |- EvalConstants.hs
|  |  |  |- Overwrite.hs
|  |  |  |- PhiElimination.hs
|  |  |  |- RemoveAss.hs
|  |  |
|  |  |- Position
|  |  |  | # contains definitions of functions returning position of syntax elements
|  |  |  |
|  |  |  |- EndPosition.hs
|  |  |  |- Position.hs
|  |  |  |- SyntaxDepPosition.hs
|  |  |  |- SyntaxPosition.hs
|  |  |
|  |  |- Syntax
|  |  |  | # contains syntax data definitions and some utils perteining to them
|  |  |  |
|  |  |  |- Bloater.hs
|  |  |  |- Debloater.hs
|  |  |  |- LangElemClasses.hs
|  |  |  |- Syntax.hs
|  |  |  |- SyntaxDep.hs
|  |  |
|  |  |- TypeCheck
|  |  |  | # contains code pertaining to type checking ie. to generation of 
|  |  |  | # dependent abstract syntax (src/src/Syntax/SyntaxDep.hs) from 
|  |  |  | # regular abstract syntax (src/src/Syntax/Syntax.hs)
|  |  |  |
|  |  |  |- Castable.hs
|  |  |  |- CheckReturns.hs
|  |  |  |- Declarations.hs
|  |  |  |- LatteGetters.hs
|  |  |  |- State.hs
|  |  |  |- StateUtils.hs
|  |  |  |- TypeCheck.hs
|  |  |
|  |  |- BuiltIns.hs
|  |  |- Constants.hs
|  |  |- Dependent.hs
|  |  |- Errors.hs
|  |  |- Program.hs
|  |  |- Scope.hs
|  |  |- SingChar.hs
|  |
|  |- latc
|  |  # gets copied to ./latc
|  |
|  |- latc_llvm
|  |  # gets copied to ./latc_llvm
|  |
|  |- latte.cf
|
|- (latc)
|- (latc_llvm)
|- (LatteCompiler.cabal)
|- Makefile
|- package.yaml
|- README.md
|- Setup.hs
|- stack.yaml
|- (stack.yaml.lock)
```
