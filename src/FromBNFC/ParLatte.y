-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module FromBNFC.ParLatte where
import FromBNFC.AbsLatte
import FromBNFC.LexLatte
import FromBNFC.ErrM

}

%name pProgram Program
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  '++' { PT _ (TS _ 3) }
  ',' { PT _ (TS _ 4) }
  '--' { PT _ (TS _ 5) }
  '.' { PT _ (TS _ 6) }
  ':' { PT _ (TS _ 7) }
  '=' { PT _ (TS _ 8) }
  '[' { PT _ (TS _ 9) }
  ']' { PT _ (TS _ 10) }

L_PTrue { PT _ (T_PTrue _) }
L_PFalse { PT _ (T_PFalse _) }
L_PTypeInt { PT _ (T_PTypeInt _) }
L_PTypeStr { PT _ (T_PTypeStr _) }
L_PTypeBool { PT _ (T_PTypeBool _) }
L_PTypeVoid { PT _ (T_PTypeVoid _) }
L_PPlus { PT _ (T_PPlus _) }
L_PMinus { PT _ (T_PMinus _) }
L_PTimes { PT _ (T_PTimes _) }
L_PDiv { PT _ (T_PDiv _) }
L_PMod { PT _ (T_PMod _) }
L_PLTH { PT _ (T_PLTH _) }
L_PLE { PT _ (T_PLE _) }
L_PGTH { PT _ (T_PGTH _) }
L_PGE { PT _ (T_PGE _) }
L_PEQU { PT _ (T_PEQU _) }
L_PNE { PT _ (T_PNE _) }
L_PAnd { PT _ (T_PAnd _) }
L_POr { PT _ (T_POr _) }
L_PNot { PT _ (T_PNot _) }
L_PLBrace { PT _ (T_PLBrace _) }
L_PRBrace { PT _ (T_PRBrace _) }
L_PSemiColon { PT _ (T_PSemiColon _) }
L_PIf { PT _ (T_PIf _) }
L_PElse { PT _ (T_PElse _) }
L_PWhile { PT _ (T_PWhile _) }
L_PFor { PT _ (T_PFor _) }
L_PReturn { PT _ (T_PReturn _) }
L_PNew { PT _ (T_PNew _) }
L_PClass { PT _ (T_PClass _) }
L_PExtends { PT _ (T_PExtends _) }
L_PIdent { PT _ (T_PIdent _) }
L_PInteger { PT _ (T_PInteger _) }
L_PString { PT _ (T_PString _) }


%%

PTrue    :: { PTrue} : L_PTrue { PTrue (mkPosToken $1)}
PFalse    :: { PFalse} : L_PFalse { PFalse (mkPosToken $1)}
PTypeInt    :: { PTypeInt} : L_PTypeInt { PTypeInt (mkPosToken $1)}
PTypeStr    :: { PTypeStr} : L_PTypeStr { PTypeStr (mkPosToken $1)}
PTypeBool    :: { PTypeBool} : L_PTypeBool { PTypeBool (mkPosToken $1)}
PTypeVoid    :: { PTypeVoid} : L_PTypeVoid { PTypeVoid (mkPosToken $1)}
PPlus    :: { PPlus} : L_PPlus { PPlus (mkPosToken $1)}
PMinus    :: { PMinus} : L_PMinus { PMinus (mkPosToken $1)}
PTimes    :: { PTimes} : L_PTimes { PTimes (mkPosToken $1)}
PDiv    :: { PDiv} : L_PDiv { PDiv (mkPosToken $1)}
PMod    :: { PMod} : L_PMod { PMod (mkPosToken $1)}
PLTH    :: { PLTH} : L_PLTH { PLTH (mkPosToken $1)}
PLE    :: { PLE} : L_PLE { PLE (mkPosToken $1)}
PGTH    :: { PGTH} : L_PGTH { PGTH (mkPosToken $1)}
PGE    :: { PGE} : L_PGE { PGE (mkPosToken $1)}
PEQU    :: { PEQU} : L_PEQU { PEQU (mkPosToken $1)}
PNE    :: { PNE} : L_PNE { PNE (mkPosToken $1)}
PAnd    :: { PAnd} : L_PAnd { PAnd (mkPosToken $1)}
POr    :: { POr} : L_POr { POr (mkPosToken $1)}
PNot    :: { PNot} : L_PNot { PNot (mkPosToken $1)}
PLBrace    :: { PLBrace} : L_PLBrace { PLBrace (mkPosToken $1)}
PRBrace    :: { PRBrace} : L_PRBrace { PRBrace (mkPosToken $1)}
PSemiColon    :: { PSemiColon} : L_PSemiColon { PSemiColon (mkPosToken $1)}
PIf    :: { PIf} : L_PIf { PIf (mkPosToken $1)}
PElse    :: { PElse} : L_PElse { PElse (mkPosToken $1)}
PWhile    :: { PWhile} : L_PWhile { PWhile (mkPosToken $1)}
PFor    :: { PFor} : L_PFor { PFor (mkPosToken $1)}
PReturn    :: { PReturn} : L_PReturn { PReturn (mkPosToken $1)}
PNew    :: { PNew} : L_PNew { PNew (mkPosToken $1)}
PClass    :: { PClass} : L_PClass { PClass (mkPosToken $1)}
PExtends    :: { PExtends} : L_PExtends { PExtends (mkPosToken $1)}
PIdent    :: { PIdent} : L_PIdent { PIdent (mkPosToken $1)}
PInteger    :: { PInteger} : L_PInteger { PInteger (mkPosToken $1)}
PString    :: { PString} : L_PString { PString (mkPosToken $1)}

Program :: { Program }
Program : ListTopDef { FromBNFC.AbsLatte.Program $1 }
TopDef :: { TopDef }
TopDef : Type PIdent '(' ListArg ')' Block { FromBNFC.AbsLatte.FnDef $1 $2 $4 $6 }
       | PClass PIdent ClassBody { FromBNFC.AbsLatte.BaseClassDef $1 $2 $3 }
       | PClass PIdent PExtends PIdent ClassBody { FromBNFC.AbsLatte.ChildClassDef $1 $2 $3 $4 $5 }
ListTopDef :: { [TopDef] }
ListTopDef : TopDef { (:[]) $1 } | TopDef ListTopDef { (:) $1 $2 }
Arg :: { Arg }
Arg : Type PIdent { FromBNFC.AbsLatte.Arg $1 $2 }
ListArg :: { [Arg] }
ListArg : {- empty -} { [] }
        | Arg { (:[]) $1 }
        | Arg ',' ListArg { (:) $1 $3 }
Block :: { Block }
Block : PLBrace ListStmt PRBrace { FromBNFC.AbsLatte.Block $1 (reverse $2) $3 }
ListStmt :: { [Stmt] }
ListStmt : {- empty -} { [] } | ListStmt Stmt { flip (:) $1 $2 }
Stmt :: { Stmt }
Stmt : PSemiColon { FromBNFC.AbsLatte.Empty $1 }
     | Block { FromBNFC.AbsLatte.BStmt $1 }
     | Type ListItem PSemiColon { FromBNFC.AbsLatte.Decl $1 $2 $3 }
     | Var '=' Expr PSemiColon { FromBNFC.AbsLatte.Ass $1 $3 $4 }
     | Var '++' PSemiColon { FromBNFC.AbsLatte.Incr $1 $3 }
     | Var '--' PSemiColon { FromBNFC.AbsLatte.Decr $1 $3 }
     | PReturn Expr PSemiColon { FromBNFC.AbsLatte.Ret $1 $2 $3 }
     | PReturn PSemiColon { FromBNFC.AbsLatte.VRet $1 $2 }
     | PIf '(' Expr ')' Stmt { FromBNFC.AbsLatte.Cond $1 $3 $5 }
     | PIf '(' Expr ')' Stmt PElse Stmt { FromBNFC.AbsLatte.CondElse $1 $3 $5 $6 $7 }
     | PWhile '(' Expr ')' Stmt { FromBNFC.AbsLatte.While $1 $3 $5 }
     | Expr PSemiColon { FromBNFC.AbsLatte.SExp $1 $2 }
     | PFor '(' Type PIdent ':' Var ')' Stmt { FromBNFC.AbsLatte.For $1 $3 $4 $6 $8 }
Item :: { Item }
Item : PIdent { FromBNFC.AbsLatte.NoInit $1 }
     | PIdent '=' Expr { FromBNFC.AbsLatte.Init $1 $3 }
ListItem :: { [Item] }
ListItem : Item { (:[]) $1 } | Item ',' ListItem { (:) $1 $3 }
Type :: { Type }
Type : PTypeInt { FromBNFC.AbsLatte.Int $1 }
     | PTypeStr { FromBNFC.AbsLatte.Str $1 }
     | PTypeBool { FromBNFC.AbsLatte.Bool $1 }
     | PTypeVoid { FromBNFC.AbsLatte.Void $1 }
     | Type '[' ']' { FromBNFC.AbsLatte.Arr $1 }
     | PIdent { FromBNFC.AbsLatte.Custom $1 }
ListType :: { [Type] }
ListType : {- empty -} { [] }
         | Type { (:[]) $1 }
         | Type ',' ListType { (:) $1 $3 }
Expr6 :: { Expr }
Expr6 : Var { FromBNFC.AbsLatte.EVar $1 }
      | PInteger { FromBNFC.AbsLatte.ELitInt $1 }
      | PTrue { FromBNFC.AbsLatte.ELitTrue $1 }
      | PFalse { FromBNFC.AbsLatte.ELitFalse $1 }
      | Var '(' ListExpr ')' { FromBNFC.AbsLatte.EApp $1 $3 }
      | PString { FromBNFC.AbsLatte.EString $1 }
      | '(' Expr ')' { $2 }
Var :: { Var }
Var : PIdent { FromBNFC.AbsLatte.Var $1 }
    | Var '.' PIdent { FromBNFC.AbsLatte.Member $1 $3 }
    | Var '[' Expr ']' { FromBNFC.AbsLatte.Elem $1 $3 }
Expr5 :: { Expr }
Expr5 : PMinus Expr6 { FromBNFC.AbsLatte.Neg $1 $2 }
      | PNot Expr6 { FromBNFC.AbsLatte.Not $1 $2 }
      | Expr6 { $1 }
      | '(' Type ')' Expr5 { FromBNFC.AbsLatte.Cast $2 $4 }
      | '(' Expr ')' Expr5 { FromBNFC.AbsLatte.CastE $2 $4 }
Expr4 :: { Expr }
Expr4 : Expr4 MulOp Expr5 { FromBNFC.AbsLatte.EMul $1 $2 $3 }
      | Expr5 { $1 }
Expr3 :: { Expr }
Expr3 : Expr3 AddOp Expr4 { FromBNFC.AbsLatte.EAdd $1 $2 $3 }
      | Expr4 { $1 }
Expr2 :: { Expr }
Expr2 : Expr2 RelOp Expr3 { FromBNFC.AbsLatte.ERel $1 $2 $3 }
      | Expr3 { $1 }
Expr1 :: { Expr }
Expr1 : Expr2 AndOp Expr1 { FromBNFC.AbsLatte.EAnd $1 $2 $3 }
      | Expr2 { $1 }
Expr :: { Expr }
Expr : Expr1 OrOp Expr { FromBNFC.AbsLatte.EOr $1 $2 $3 }
     | Expr1 { $1 }
     | PNew Type '[' Expr ']' { FromBNFC.AbsLatte.NewArr $1 $2 $4 }
     | PNew PIdent { FromBNFC.AbsLatte.NewObj $1 $2 }
ListExpr :: { [Expr] }
ListExpr : {- empty -} { [] }
         | Expr { (:[]) $1 }
         | Expr ',' ListExpr { (:) $1 $3 }
AddOp :: { AddOp }
AddOp : PPlus { FromBNFC.AbsLatte.Plus $1 }
      | PMinus { FromBNFC.AbsLatte.Minus $1 }
MulOp :: { MulOp }
MulOp : PTimes { FromBNFC.AbsLatte.Times $1 }
      | PDiv { FromBNFC.AbsLatte.Div $1 }
      | PMod { FromBNFC.AbsLatte.Mod $1 }
RelOp :: { RelOp }
RelOp : PLTH { FromBNFC.AbsLatte.LTH $1 }
      | PLE { FromBNFC.AbsLatte.LE $1 }
      | PGTH { FromBNFC.AbsLatte.GTH $1 }
      | PGE { FromBNFC.AbsLatte.GE $1 }
      | PEQU { FromBNFC.AbsLatte.EQU $1 }
      | PNE { FromBNFC.AbsLatte.NE $1 }
AndOp :: { AndOp }
AndOp : PAnd { FromBNFC.AbsLatte.And $1 }
OrOp :: { OrOp }
OrOp : POr { FromBNFC.AbsLatte.Or $1 }
ClassBody :: { ClassBody }
ClassBody : PLBrace ListMemberDecl PRBrace { FromBNFC.AbsLatte.ClassBody $1 (reverse $2) $3 }
MemberDecl :: { MemberDecl }
MemberDecl : Type PIdent PSemiColon { FromBNFC.AbsLatte.AttrDecl $1 $2 $3 }
           | TopDef { FromBNFC.AbsLatte.MethodDecl $1 }
ListMemberDecl :: { [MemberDecl] }
ListMemberDecl : {- empty -} { [] }
               | ListMemberDecl MemberDecl { flip (:) $1 $2 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

