-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module FromBNFC.ParLatte where
import FromBNFC.AbsLatte
import FromBNFC.LexLatte
import FromBNFC.ErrM

}

%name pProgram Program
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '!' { PT _ (TS _ 1) }
  '&&' { PT _ (TS _ 2) }
  '(' { PT _ (TS _ 3) }
  ')' { PT _ (TS _ 4) }
  '++' { PT _ (TS _ 5) }
  ',' { PT _ (TS _ 6) }
  '--' { PT _ (TS _ 7) }
  ';' { PT _ (TS _ 8) }
  '=' { PT _ (TS _ 9) }
  'else' { PT _ (TS _ 10) }
  'if' { PT _ (TS _ 11) }
  'while' { PT _ (TS _ 12) }
  '{' { PT _ (TS _ 13) }
  '||' { PT _ (TS _ 14) }
  '}' { PT _ (TS _ 15) }

L_PTrue { PT _ (T_PTrue _) }
L_PFalse { PT _ (T_PFalse _) }
L_PReturn { PT _ (T_PReturn _) }
L_PTypeInt { PT _ (T_PTypeInt _) }
L_PTypeStr { PT _ (T_PTypeStr _) }
L_PTypeBool { PT _ (T_PTypeBool _) }
L_PTypeVoid { PT _ (T_PTypeVoid _) }
L_PPlus { PT _ (T_PPlus _) }
L_PMinus { PT _ (T_PMinus _) }
L_PTimes { PT _ (T_PTimes _) }
L_PDiv { PT _ (T_PDiv _) }
L_PMod { PT _ (T_PMod _) }
L_PLTH { PT _ (T_PLTH _) }
L_PLE { PT _ (T_PLE _) }
L_PGTH { PT _ (T_PGTH _) }
L_PGE { PT _ (T_PGE _) }
L_PEQU { PT _ (T_PEQU _) }
L_PNE { PT _ (T_PNE _) }
L_PIdent { PT _ (T_PIdent _) }
L_PInteger { PT _ (T_PInteger _) }
L_PString { PT _ (T_PString _) }


%%

PTrue    :: { PTrue} : L_PTrue { PTrue (mkPosToken $1)}
PFalse    :: { PFalse} : L_PFalse { PFalse (mkPosToken $1)}
PReturn    :: { PReturn} : L_PReturn { PReturn (mkPosToken $1)}
PTypeInt    :: { PTypeInt} : L_PTypeInt { PTypeInt (mkPosToken $1)}
PTypeStr    :: { PTypeStr} : L_PTypeStr { PTypeStr (mkPosToken $1)}
PTypeBool    :: { PTypeBool} : L_PTypeBool { PTypeBool (mkPosToken $1)}
PTypeVoid    :: { PTypeVoid} : L_PTypeVoid { PTypeVoid (mkPosToken $1)}
PPlus    :: { PPlus} : L_PPlus { PPlus (mkPosToken $1)}
PMinus    :: { PMinus} : L_PMinus { PMinus (mkPosToken $1)}
PTimes    :: { PTimes} : L_PTimes { PTimes (mkPosToken $1)}
PDiv    :: { PDiv} : L_PDiv { PDiv (mkPosToken $1)}
PMod    :: { PMod} : L_PMod { PMod (mkPosToken $1)}
PLTH    :: { PLTH} : L_PLTH { PLTH (mkPosToken $1)}
PLE    :: { PLE} : L_PLE { PLE (mkPosToken $1)}
PGTH    :: { PGTH} : L_PGTH { PGTH (mkPosToken $1)}
PGE    :: { PGE} : L_PGE { PGE (mkPosToken $1)}
PEQU    :: { PEQU} : L_PEQU { PEQU (mkPosToken $1)}
PNE    :: { PNE} : L_PNE { PNE (mkPosToken $1)}
PIdent    :: { PIdent} : L_PIdent { PIdent (mkPosToken $1)}
PInteger    :: { PInteger} : L_PInteger { PInteger (mkPosToken $1)}
PString    :: { PString} : L_PString { PString (mkPosToken $1)}

Program :: { Program }
Program : ListTopDef { FromBNFC.AbsLatte.Program $1 }
TopDef :: { TopDef }
TopDef : Type PIdent '(' ListArg ')' Block { FromBNFC.AbsLatte.FnDef $1 $2 $4 $6 }
ListTopDef :: { [TopDef] }
ListTopDef : TopDef { (:[]) $1 } | TopDef ListTopDef { (:) $1 $2 }
Arg :: { Arg }
Arg : Type PIdent { FromBNFC.AbsLatte.Arg $1 $2 }
ListArg :: { [Arg] }
ListArg : {- empty -} { [] }
        | Arg { (:[]) $1 }
        | Arg ',' ListArg { (:) $1 $3 }
Block :: { Block }
Block : '{' ListStmt '}' { FromBNFC.AbsLatte.Block (reverse $2) }
ListStmt :: { [Stmt] }
ListStmt : {- empty -} { [] } | ListStmt Stmt { flip (:) $1 $2 }
Stmt :: { Stmt }
Stmt : ';' { FromBNFC.AbsLatte.Empty }
     | Block { FromBNFC.AbsLatte.BStmt $1 }
     | Type ListItem ';' { FromBNFC.AbsLatte.Decl $1 $2 }
     | PIdent '=' Expr ';' { FromBNFC.AbsLatte.Ass $1 $3 }
     | PIdent '++' ';' { FromBNFC.AbsLatte.Incr $1 }
     | PIdent '--' ';' { FromBNFC.AbsLatte.Decr $1 }
     | PReturn Expr ';' { FromBNFC.AbsLatte.Ret $1 $2 }
     | PReturn ';' { FromBNFC.AbsLatte.VRet $1 }
     | 'if' '(' Expr ')' Stmt { FromBNFC.AbsLatte.Cond $3 $5 }
     | 'if' '(' Expr ')' Stmt 'else' Stmt { FromBNFC.AbsLatte.CondElse $3 $5 $7 }
     | 'while' '(' Expr ')' Stmt { FromBNFC.AbsLatte.While $3 $5 }
     | Expr ';' { FromBNFC.AbsLatte.SExp $1 }
Item :: { Item }
Item : PIdent { FromBNFC.AbsLatte.NoInit $1 }
     | PIdent '=' Expr { FromBNFC.AbsLatte.Init $1 $3 }
ListItem :: { [Item] }
ListItem : Item { (:[]) $1 } | Item ',' ListItem { (:) $1 $3 }
Type :: { Type }
Type : PTypeInt { FromBNFC.AbsLatte.Int $1 }
     | PTypeStr { FromBNFC.AbsLatte.Str $1 }
     | PTypeBool { FromBNFC.AbsLatte.Bool $1 }
     | PTypeVoid { FromBNFC.AbsLatte.Void $1 }
ListType :: { [Type] }
ListType : {- empty -} { [] }
         | Type { (:[]) $1 }
         | Type ',' ListType { (:) $1 $3 }
Expr6 :: { Expr }
Expr6 : PIdent { FromBNFC.AbsLatte.EVar $1 }
      | PInteger { FromBNFC.AbsLatte.ELitInt $1 }
      | PTrue { FromBNFC.AbsLatte.ELitTrue $1 }
      | PFalse { FromBNFC.AbsLatte.ELitFalse $1 }
      | PIdent '(' ListExpr ')' { FromBNFC.AbsLatte.EApp $1 $3 }
      | PString { FromBNFC.AbsLatte.EString $1 }
      | '(' Expr ')' { $2 }
Expr5 :: { Expr }
Expr5 : PMinus Expr6 { FromBNFC.AbsLatte.Neg $1 $2 }
      | '!' Expr6 { FromBNFC.AbsLatte.Not $2 }
      | Expr6 { $1 }
Expr4 :: { Expr }
Expr4 : Expr4 MulOp Expr5 { FromBNFC.AbsLatte.EMul $1 $2 $3 }
      | Expr5 { $1 }
Expr3 :: { Expr }
Expr3 : Expr3 AddOp Expr4 { FromBNFC.AbsLatte.EAdd $1 $2 $3 }
      | Expr4 { $1 }
Expr2 :: { Expr }
Expr2 : Expr2 RelOp Expr3 { FromBNFC.AbsLatte.ERel $1 $2 $3 }
      | Expr3 { $1 }
Expr1 :: { Expr }
Expr1 : Expr2 '&&' Expr1 { FromBNFC.AbsLatte.EAnd $1 $3 }
      | Expr2 { $1 }
Expr :: { Expr }
Expr : Expr1 '||' Expr { FromBNFC.AbsLatte.EOr $1 $3 }
     | Expr1 { $1 }
ListExpr :: { [Expr] }
ListExpr : {- empty -} { [] }
         | Expr { (:[]) $1 }
         | Expr ',' ListExpr { (:) $1 $3 }
AddOp :: { AddOp }
AddOp : PPlus { FromBNFC.AbsLatte.Plus $1 }
      | PMinus { FromBNFC.AbsLatte.Minus $1 }
MulOp :: { MulOp }
MulOp : PTimes { FromBNFC.AbsLatte.Times $1 }
      | PDiv { FromBNFC.AbsLatte.Div $1 }
      | PMod { FromBNFC.AbsLatte.Mod $1 }
RelOp :: { RelOp }
RelOp : PLTH { FromBNFC.AbsLatte.LTH $1 }
      | PLE { FromBNFC.AbsLatte.LE $1 }
      | PGTH { FromBNFC.AbsLatte.GTH $1 }
      | PGE { FromBNFC.AbsLatte.GE $1 }
      | PEQU { FromBNFC.AbsLatte.EQU $1 }
      | PNE { FromBNFC.AbsLatte.NE $1 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

